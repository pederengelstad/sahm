Xf[,j] <- pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
}
y.lim<-c(0,1)
#I'm not quite sure what the logical limits are for poisson but 0 1 doesn't work I might be able to take the max
#of the predicted values but I'm not sure this would work for every situation
if(out$input$model.family=="poisson") y.lim=range(apply(Xf,1,mean))
plot(Xp1[, i],apply(Xf,1,mean), ylim = y.lim, xlab = "",
ylab = "", type = "l", main = names(dat)[i],lwd=ifelse(k==1,4,6),cex=3,cex.main=6,xaxt="n",yaxt="n")
if(k==2) mtext("Predicted Value", side=2,line=6,cex=6)
axis(1,labels=FALSE)
axis(2,labels=FALSE)
axis(1,line=2,lwd=0,cex.axis=4)
axis(2,line=1,lwd=0,cex.axis=4)
rug(dat[resp==1,i],col="red",lwd=2)
rug(dat[resp==0,i],col="blue",lwd=2)
if(k==2) graphics.off()
if(k==2) {if(i==min(sort(match(out$mods$vnames,names(dat))))) rsp.dat<-cbind(Xp1[, i],apply(Xf,1,mean))
else rsp.dat<-cbind(rsp.dat,Xp1[, i],apply(Xf,1,mean))
colnames(rsp.dat)[(ncol(rsp.dat)-1):(ncol(rsp.dat))]<-c(names(dat)[i],basename(out$input$output.dir))
}
}
if(k==1){
mtext("Predicted Value",side=2,cex=5,line=2,outer=TRUE)
graphics.off()}
}
k
k = 1
if(k==1){ jpeg(file.path(out$input$output.dir,"responseCurves","all_response_curves.jpg"),width=2000,height=2000,quality=100)
par(oma=c(2,8,4,2),mfrow=c(prow,pcol))}
sort(match(out$mods$vnames,names(dat)))
i=1
if (k==2){ jpeg(filename=file.path(out$input$output.dir,"responseCurves",paste(names(dat)[i],".jpg",sep="")),width=2000,height=2000,quality=100)
par(mar=c(7,10,8,1))
}
if (!is.factor(dat[, i])) {
xr <- range(dat[, i])
Xp1 <- Xp
Xp1[, i] <- seq(xr[1], xr[2], len = nrow(dat))
}
else {
Xp1 <- Xp
Nrepcat <- floor(nrow(dat)/length(levels(dat[,
i])))
Xp1[, i] <- as.factor(c(rep(levels(dat[, i])[1],
nrow(dat) - (Nrepcat * length(levels(dat[,
i])))), rep(levels(dat[, i]), each = Nrepcat)))
}
if (!is.factor(dat[, i])) {
xr <- range(dat[, i])
Xp1 <- Xp
Xp1[, i] <- seq(xr[1], xr[2], len = nrow(dat))
}
else {
Xp1 <- Xp
Nrepcat <- floor(nrow(dat)/length(levels(dat[,
i])))
Xp1[, i] <- as.factor(c(rep(levels(dat[, i])[1],
nrow(dat) - (Nrepcat * length(levels(dat[,
i])))), rep(levels(dat[, i]), each = Nrepcat)))
}
if(!is.factor(dat[, i])) {
xr <- range(dat[, i])
Xp1 <- Xp
Xp1[, i] <- seq(xr[1], xr[2], len = nrow(dat))
} else {
Xp1 <- Xp
Nrepcat <- floor(nrow(dat)/length(levels(dat[,
i])))
Xp1[, i] <- as.factor(c(rep(levels(dat[, i])[1],
nrow(dat) - (Nrepcat * length(levels(dat[,
i])))), rep(levels(dat[, i]), each = Nrepcat)))
}
Xf<-matrix(nrow=nrow(Xp1),ncol=max(length(out$mods$final.mod),1))
Xf
1:max(1,length(out$mods$final.mod))
out$mods$final.mod
Xf[,j] <- pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
Xf
Xp1
j
j = 1
pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
for(j in 1:max(1,length(out$mods$final.mod))){
print(j)
# Xf[,j] <- pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
}
Xf
Xf<-matrix(nrow=nrow(Xp1),ncol=max(length(out$mods$final.mod),1))
Xf
Xf[,j] <- pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
Xf
pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
as.data.frame(Xp1)
Xf<-matrix(nrow=nrow(Xp1),ncol=max(length(out$mods$final.mod),1))
Model
out$mods$final.mod[[j]]
length(out$mods$final.mod)
for(j in 1:max(1,length(out$mods$final.mod))){
print(j)
# Xf[,j] <- pred.fct(out$mods$final.mod[[j]], as.data.frame(Xp1),Model)
}
j = 1
out$mods$final.mod[[j]]
# Using brewer's sparrow data
### Replicate call:
csv = "C:/Users/peder/Documents/testing_SAHM/testing212/brewersSparrow/xgb_1/CovariateCorrelationOutputMDS_initial.csv"
output = "C:/Users/peder/Documents/testing_SAHM/testing212/brewersSparrow/xgb_1/"
responseCol = 'responseBinary'
nrounds = 10
make.p.tif = F
make.binary.tif = F
make.r.curves = T
seed = NULL
opt.methods = 2
seed = NULL
MESS = FALSE
xtest = NULL
ytest = NULL
ScriptPath = "C:/Users/peder/.vistrails/userpackages/../userpackages/sahm_2_1_2/pySAHM/Resources/R_Modules/FIT_XGB_pluggable.r"
ScriptPath = dirname(ScriptPath)
source(file.path(ScriptPath,"LoadRequiredCode.r"))
# First function called is FitModels
# These are the loaded args
ma.name = csv
tif.dir = NULL
output.dir = output
response.col = responseCol
make.p.tif = make.p.tif
make.binary.tif = make.binary.tif
debug.mode = F
xtest = xtest
ytest = ytest
nrounds = nrounds
make.r.curves=make.r.curves
seed = seed
script.name = "xgb"
opt.methods = opt.methods
MESS = MESS
ScriptPath = ScriptPath
multCore = F
t0 = unclass(Sys.time())
# in R Studio, this has to be written differently - cmd line args will need to be specified in Py as well.
out = list(input = list('ma.name' = ma.name, 'tif.dir' = tif.dir, 'output.dir' = output.dir,
'debug.mode' = debug.mode, 'make.p.tif' = make.p.tif, 'make.binary.tif' = make.binary.tif,
'response.col' = response.col, 'MESS' = MESS, 'nrounds' = nrounds,
'ScriptPath' = ScriptPath, 'multCore' = multCore, 'script.name' = script.name,
'opt.methods' = opt.methods),
dat = list(),                                        # Captures output from read.ma() function
mods = list(final.mod = NULL,
tif.output = list(prob = NULL, bin = NULL),
auc.output = NULL,
interactions = NULL,  # not used #
summary = NULL)
)
if(is.null(out$input$seed)) out$input$seed = round(runif(1, min = -((2^32)/2-1), max = ((2^32)/2-1)))
set.seed(as.numeric(out$input$seed))
Model = script.name
# Generate a filename for output
if(debug.mode == TRUE){
bname = file.path(out$input$output.dir, paste(Model, "_", n <- 1, sep = ""))
while(file.access(paste(bname, "_output.txt", sep = "")) == 0) bname = file.path(out$input$output.dir, paste(Model, "_", n <- n+1, sep=""))
} else{
out$dat$bname = bname = file.path(out$input$output.dir, Model)
}
capture.output(paste(toupper(Model), "Results"), file = paste(bname, "_output.txt", sep = "")) # reserve the new basename
on.exit(capture.output(cat("Model Failed\n\n"), file = paste(out$dat$bname, "_output.txt", sep = ""), append = TRUE))
chk.libs(Model)
#Read in data, perform several checks and store all of the information in the out list
out = read.ma(out)
out$dat$bname = bname
out$dat$bnameExpanded = file.path(dirname(out$dat$bname), "ExpandedOutput")
dir.create(out$dat$bnameExpanded)
if(out$input$script.name == "rf" & out$input$model.family == "poisson") stop("Random Forest not implemented for count data")
out = place.save(out)
out$dat$split.label = out$dat$split.type
#Fit the desired model#
out = generic.model.fit(out, Model, t0)
# Making Predictions
pred.vals = function(x, model, Model){
x$pred = pred.fct(model, x$dat[,2:ncol(x$dat)], Model)
return(x)
}
# Getting the predictions for the test/train or cross validation splits into the object at the correct list location
if(out$dat$split.type != "crossValidation"){
out$dat$ma = lapply(X = out$dat$ma, FUN = pred.vals, model = out$mods$final.mod, Model = Model)
} else {
out$dat$ma$train$pred = pred.vals(out$dat$ma$train, out$mods$final.mod, Model = Model)$pred
}
# For the training set in Random Forest we have to take out of bag predictions rather than the regular predictions
if(Model == "rf") out$dat$ma$train$pred = tweak.p(out$mods$predictions)
# For udc predicted probabilities of zero or 1 break devaince so we tweak these too
if(Model == "udc"){
out$dat$ma$train$pred[out$dat$ma$train$pred == 0] = .0000001
out$dat$ma$train$pred[out$dat$ma$train$pred == 1] = .9999999
out$dat$split.type = "none"
}
#Run Cross Validation if specified might need separate cv functions for each model
if(out$dat$split.type == "crossValidation") out = cv.fct(out$mods$final.mod, out = out, sp.no = 1, prev.stratify = F, Model = Model)
assign("out", out, envir = .GlobalEnv)
t3 = unclass(Sys.time())
if(!is.null(out$dat$bad.factor.cols)){
capture.output(cat("\nWarning: the following categorical response variables were removed from consideration\n",
"because they had only one level:",paste(out$dat$bad.factor.cols, collapse = ","), "\n"),
file = paste(bname, "_output.txt", sep = ""), append = T)
}
if(nrow(out$dat$ma$train$dat)/(ncol(out$dat$ma$train$dat)-1)<10){
capture.output(cat(paste("\n Warning: You have approximately ", round(nrow(out$dat$ma$train$dat)/(ncol(out$dat$ma$train$dat)-1), digits = 1),
" observations for every predictor\n consider reducing the number of predictors before continuing\n", sep = "")),
file = paste(bname, "_output.txt", sep = ""), append = T)
}
cat("40%\n")
#needs step through, variable importance image also looks funky with large values of nrounds (extremem overfitting, most likely)
out$mods$auc.output = suppressWarnings(make.auc.plot.jpg(out = out))
cat("Progress:70%\n");flush.console()
#Response curves
response.curves(out, Model)
#Save Workspace
save.image(file.path(output.dir, "modelWorkspace"))
t4 = unclass(Sys.time())
cat("\nfinished with final model summarization, t=", round(t4-t3, 2), "sec\n");flush.console()
cat("Progress:80%\n");flush.console()
# Make .tif of predictions #
if(out$input$make.p.tif == T | out$input$make.binary.tif == T){
if((n.var <- out$mods$n.vars.final) < 1){
stop("Error producing geotiff output:  null model selected by stepwise procedure - pointless to make maps")
} else {
cat("\nproducing prediction maps...", "\n", "\n");flush.console()
proc.tiff(model = out$mods$final.mod,
vnames = names(out$dat$ma$train$dat)[-1],
tif.dir = out$dat$tif.dir$dname,
filenames = out$dat$tif.ind,
factor.levels = out$dat$factor.levels,
make.binary.tif = make.binary.tif,
thresh = out$mods$auc.output$thresh,
make.p.tif = make.p.tif,
outfile.p = paste(out$dat$bname, "_prob_map.tif", sep=""),
outfile.bin = paste(out$dat$bname, "_bin_map.tif", sep=""),
tsize = 50.0,
NAval = -3000,
fnames = out$dat$tif.names,
out = out,
Model = Model)
}
if(make.p.tif) out$mods$tif.output$prob = paste(out$dat$bname, "_prob_map.tif", sep = "")
if(make.binary.tif) out$mods$tif.output$bin = paste(out$dat$bname, "_bin_map.tif", sep = "")
t5 = unclass(Sys.time())
cat("\nfinished with prediction maps, t=", round(t5-t4, 2), "sec\n");flush.console()
}
# Make .tif of predictions #
if(out$input$make.p.tif == T | out$input$make.binary.tif == T){
if((n.var <- out$mods$n.vars.final) < 1){
stop("Error producing geotiff output:  null model selected by stepwise procedure - pointless to make maps")
} else {
cat("\nproducing prediction maps...", "\n", "\n");flush.console()
proc.tiff(model = out$mods$final.mod,
vnames = names(out$dat$ma$train$dat)[-1],
tif.dir = out$dat$tif.dir$dname,
filenames = out$dat$tif.ind,
factor.levels = out$dat$factor.levels,
make.binary.tif = make.binary.tif,
thresh = out$mods$auc.output$thresh,
make.p.tif = make.p.tif,
outfile.p = paste(out$dat$bname, "_prob_map.tif", sep=""),
outfile.bin = paste(out$dat$bname, "_bin_map.tif", sep=""),
tsize = 50.0,
NAval = -3000,
fnames = out$dat$tif.names,
out = out,
Model = Model)
}
if(make.p.tif) out$mods$tif.output$prob = paste(out$dat$bname, "_prob_map.tif", sep = "")
if(make.binary.tif) out$mods$tif.output$bin = paste(out$dat$bname, "_bin_map.tif", sep = "")
t5 = unclass(Sys.time())
cat("\nfinished with prediction maps, t=", round(t5-t4, 2), "sec\n");flush.console()
}
out$input$make.p.tif == T | out$input$make.binary.tif == T
out$input$make.p.tif=T
# Make .tif of predictions #
if(out$input$make.p.tif == T | out$input$make.binary.tif == T){
if((n.var <- out$mods$n.vars.final) < 1){
stop("Error producing geotiff output:  null model selected by stepwise procedure - pointless to make maps")
} else {
cat("\nproducing prediction maps...", "\n", "\n");flush.console()
proc.tiff(model = out$mods$final.mod,
vnames = names(out$dat$ma$train$dat)[-1],
tif.dir = out$dat$tif.dir$dname,
filenames = out$dat$tif.ind,
factor.levels = out$dat$factor.levels,
make.binary.tif = make.binary.tif,
thresh = out$mods$auc.output$thresh,
make.p.tif = make.p.tif,
outfile.p = paste(out$dat$bname, "_prob_map.tif", sep=""),
outfile.bin = paste(out$dat$bname, "_bin_map.tif", sep=""),
tsize = 50.0,
NAval = -3000,
fnames = out$dat$tif.names,
out = out,
Model = Model)
}
if(make.p.tif) out$mods$tif.output$prob = paste(out$dat$bname, "_prob_map.tif", sep = "")
if(make.binary.tif) out$mods$tif.output$bin = paste(out$dat$bname, "_bin_map.tif", sep = "")
t5 = unclass(Sys.time())
cat("\nfinished with prediction maps, t=", round(t5-t4, 2), "sec\n");flush.console()
}
# Make .tif of predictions #
if(out$input$make.p.tif == T | out$input$make.binary.tif == T){
if((n.var <- out$mods$n.vars.final) < 1){
stop("Error producing geotiff output:  null model selected by stepwise procedure - pointless to make maps")
} else {
cat("\nproducing prediction maps...", "\n", "\n");flush.console()
proc.tiff(model = out$mods$final.mod,
vnames = names(out$dat$ma$train$dat)[-1],
tif.dir = out$dat$tif.dir$dname,
filenames = out$dat$tif.ind,
factor.levels = out$dat$factor.levels,
make.binary.tif = make.binary.tif,
thresh = out$mods$auc.output$thresh,
make.p.tif = make.p.tif,
outfile.p = paste(out$dat$bname, "_prob_map.tif", sep=""),
outfile.bin = paste(out$dat$bname, "_bin_map.tif", sep=""),
tsize = 50.0,
NAval = -3000,
fnames = out$dat$tif.names,
out = out,
Model = Model)
}
if(make.p.tif) out$mods$tif.output$prob = paste(out$dat$bname, "_prob_map.tif", sep = "")
if(make.binary.tif) out$mods$tif.output$bin = paste(out$dat$bname, "_bin_map.tif", sep = "")
t5 = unclass(Sys.time())
cat("\nfinished with prediction maps, t=", round(t5-t4, 2), "sec\n");flush.console()
}
make.bin.tif = F
# Make .tif of predictions #
if(out$input$make.p.tif == T | out$input$make.binary.tif == T){
if((n.var <- out$mods$n.vars.final) < 1){
stop("Error producing geotiff output:  null model selected by stepwise procedure - pointless to make maps")
} else {
cat("\nproducing prediction maps...", "\n", "\n");flush.console()
proc.tiff(model = out$mods$final.mod,
vnames = names(out$dat$ma$train$dat)[-1],
tif.dir = out$dat$tif.dir$dname,
filenames = out$dat$tif.ind,
factor.levels = out$dat$factor.levels,
make.binary.tif = make.binary.tif,
thresh = out$mods$auc.output$thresh,
make.p.tif = make.p.tif,
outfile.p = paste(out$dat$bname, "_prob_map.tif", sep=""),
outfile.bin = paste(out$dat$bname, "_bin_map.tif", sep=""),
tsize = 50.0,
NAval = -3000,
fnames = out$dat$tif.names,
out = out,
Model = Model)
}
if(make.p.tif) out$mods$tif.output$prob = paste(out$dat$bname, "_prob_map.tif", sep = "")
if(make.binary.tif) out$mods$tif.output$bin = paste(out$dat$bname, "_bin_map.tif", sep = "")
t5 = unclass(Sys.time())
cat("\nfinished with prediction maps, t=", round(t5-t4, 2), "sec\n");flush.console()
}
cat("Progress:100%\n");flush.console()
on.exit(capture.output(cat(paste("\nTotal time = ", round((unclass(Sys.time())-t0)/60, 2), " min\n\n", sep = "")), file = paste(out$dat$bname, "_output.txt", sep = ""), append = TRUE))
invisible(out)
?invisible
# Using brewer's sparrow data
### Replicate call:
csv = "C:/Users/peder/Documents/testing_SAHM/testing212/brewersSparrow/xgb_1/CovariateCorrelationOutputMDS_initial.csv"
output = "C:/Users/peder/Documents/testing_SAHM/testing212/brewersSparrow/xgb_1/"
responseCol = 'responseBinary'
nrounds = 10
make.p.tif = F
make.binary.tif = F
make.bin.tif = F
make.r.curves = T
seed = NULL
opt.methods = 2
seed = NULL
MESS = FALSE
xtest = NULL
ytest = NULL
ScriptPath = "C:/Users/peder/.vistrails/userpackages/../userpackages/sahm_2_1_2/pySAHM/Resources/R_Modules/FIT_XGB_pluggable.r"
ScriptPath = dirname(ScriptPath)
source(file.path(ScriptPath,"LoadRequiredCode.r"))
# First function called is FitModels
# These are the loaded args
ma.name = csv
tif.dir = NULL
output.dir = output
response.col = responseCol
make.p.tif = make.p.tif
make.binary.tif = make.binary.tif
debug.mode = F
xtest = xtest
ytest = ytest
nrounds = nrounds
make.r.curves=make.r.curves
seed = seed
script.name = "xgb"
opt.methods = opt.methods
MESS = MESS
ScriptPath = ScriptPath
multCore = F
t0 = unclass(Sys.time())
# in R Studio, this has to be written differently - cmd line args will need to be specified in Py as well.
out = list(input = list('ma.name' = ma.name, 'tif.dir' = tif.dir, 'output.dir' = output.dir,
'debug.mode' = debug.mode, 'make.p.tif' = make.p.tif, 'make.binary.tif' = make.binary.tif,
'response.col' = response.col, 'MESS' = MESS, 'nrounds' = nrounds,
'ScriptPath' = ScriptPath, 'multCore' = multCore, 'script.name' = script.name,
'opt.methods' = opt.methods),
dat = list(),                                        # Captures output from read.ma() function
mods = list(final.mod = NULL,
tif.output = list(prob = NULL, bin = NULL),
auc.output = NULL,
interactions = NULL,  # not used #
summary = NULL)
)
if(is.null(out$input$seed)) out$input$seed = round(runif(1, min = -((2^32)/2-1), max = ((2^32)/2-1)))
set.seed(as.numeric(out$input$seed))
Model = script.name
# Generate a filename for output
if(debug.mode == TRUE){
bname = file.path(out$input$output.dir, paste(Model, "_", n <- 1, sep = ""))
while(file.access(paste(bname, "_output.txt", sep = "")) == 0) bname = file.path(out$input$output.dir, paste(Model, "_", n <- n+1, sep=""))
} else{
out$dat$bname = bname = file.path(out$input$output.dir, Model)
}
capture.output(paste(toupper(Model), "Results"), file = paste(bname, "_output.txt", sep = "")) # reserve the new basename
on.exit(capture.output(cat("Model Failed\n\n"), file = paste(out$dat$bname, "_output.txt", sep = ""), append = TRUE))
chk.libs(Model)
#Read in data, perform several checks and store all of the information in the out list
out = read.ma(out)
out$dat$bname = bname
out$dat$bnameExpanded = file.path(dirname(out$dat$bname), "ExpandedOutput")
dir.create(out$dat$bnameExpanded)
if(out$input$script.name == "rf" & out$input$model.family == "poisson") stop("Random Forest not implemented for count data")
out = place.save(out)
out$dat$split.label = out$dat$split.type
#Fit the desired model#
out = generic.model.fit(out, Model, t0)
# Making Predictions
pred.vals = function(x, model, Model){
x$pred = pred.fct(model, x$dat[,2:ncol(x$dat)], Model)
return(x)
}
# Getting the predictions for the test/train or cross validation splits into the object at the correct list location
if(out$dat$split.type != "crossValidation"){
out$dat$ma = lapply(X = out$dat$ma, FUN = pred.vals, model = out$mods$final.mod, Model = Model)
} else {
out$dat$ma$train$pred = pred.vals(out$dat$ma$train, out$mods$final.mod, Model = Model)$pred
}
# For the training set in Random Forest we have to take out of bag predictions rather than the regular predictions
if(Model == "rf") out$dat$ma$train$pred = tweak.p(out$mods$predictions)
# For udc predicted probabilities of zero or 1 break devaince so we tweak these too
if(Model == "udc"){
out$dat$ma$train$pred[out$dat$ma$train$pred == 0] = .0000001
out$dat$ma$train$pred[out$dat$ma$train$pred == 1] = .9999999
out$dat$split.type = "none"
}
#Run Cross Validation if specified might need separate cv functions for each model
if(out$dat$split.type == "crossValidation") out = cv.fct(out$mods$final.mod, out = out, sp.no = 1, prev.stratify = F, Model = Model)
assign("out", out, envir = .GlobalEnv)
t3 = unclass(Sys.time())
if(!is.null(out$dat$bad.factor.cols)){
capture.output(cat("\nWarning: the following categorical response variables were removed from consideration\n",
"because they had only one level:",paste(out$dat$bad.factor.cols, collapse = ","), "\n"),
file = paste(bname, "_output.txt", sep = ""), append = T)
}
if(nrow(out$dat$ma$train$dat)/(ncol(out$dat$ma$train$dat)-1)<10){
capture.output(cat(paste("\n Warning: You have approximately ", round(nrow(out$dat$ma$train$dat)/(ncol(out$dat$ma$train$dat)-1), digits = 1),
" observations for every predictor\n consider reducing the number of predictors before continuing\n", sep = "")),
file = paste(bname, "_output.txt", sep = ""), append = T)
}
cat("40%\n")
#needs step through, variable importance image also looks funky with large values of nrounds (extremem overfitting, most likely)
out$mods$auc.output = suppressWarnings(make.auc.plot.jpg(out = out))
cat("Progress:70%\n");flush.console()
#Response curves
response.curves(out, Model)
#Save Workspace
save.image(file.path(output.dir, "modelWorkspace"))
t4 = unclass(Sys.time())
cat("\nfinished with final model summarization, t=", round(t4-t3, 2), "sec\n");flush.console()
cat("Progress:80%\n");flush.console()
# Make .tif of predictions #
if(out$input$make.p.tif == T | out$input$make.binary.tif == T){
if((n.var <- out$mods$n.vars.final) < 1){
stop("Error producing geotiff output:  null model selected by stepwise procedure - pointless to make maps")
} else {
cat("\nproducing prediction maps...", "\n", "\n");flush.console()
proc.tiff(model = out$mods$final.mod,
vnames = names(out$dat$ma$train$dat)[-1],
tif.dir = out$dat$tif.dir$dname,
filenames = out$dat$tif.ind,
factor.levels = out$dat$factor.levels,
make.binary.tif = make.binary.tif,
thresh = out$mods$auc.output$thresh,
make.p.tif = make.p.tif,
outfile.p = paste(out$dat$bname, "_prob_map.tif", sep=""),
outfile.bin = paste(out$dat$bname, "_bin_map.tif", sep=""),
tsize = 50.0,
NAval = -3000,
fnames = out$dat$tif.names,
out = out,
Model = Model)
}
if(make.p.tif) out$mods$tif.output$prob = paste(out$dat$bname, "_prob_map.tif", sep = "")
if(make.binary.tif) out$mods$tif.output$bin = paste(out$dat$bname, "_bin_map.tif", sep = "")
t5 = unclass(Sys.time())
cat("\nfinished with prediction maps, t=", round(t5-t4, 2), "sec\n");flush.console()
}
cat("Progress:100%\n");flush.console()
on.exit(capture.output(cat(paste("\nTotal time = ", round((unclass(Sys.time())-t0)/60, 2), " min\n\n", sep = "")), file = paste(out$dat$bname, "_output.txt", sep = ""), append = TRUE))
invisible(out)
